\section{Research Plan and Methodology} \label{sec:rep}

This \xxx project tackles concurrency attacks with a thorough, systematic 
methodology. To this end, this section presents three objectives in this 
section, including a general, rigorous concurrency attack model 
(\S\ref{sec:model}), a systematic concurrency attack detection approach 
(\S\ref{sec:detect}) by leveraging this model, and a runtime defense 
infrastructure (\S\ref{sec:defense}). Each objective includes our preliminary 
results. Finally, this section describes our research plan (\S\ref{sec:plan}).

\vspace{-.15in}\subsection{Objective 1: Modeling Concurrency Attacks} 
\label{sec:model}\vspace{-.075in}

% P1: as mentioned in background, a key reason is thread interleavings, 
% so we need to reason about the general patterns we have. Or we say our 
% methodology is just like pattern matching.
As mentioned in \S\ref{sec:background}, state-of-the-art lacks a rigorous model 
for concurrency attacks. Specifically, people lack understanding on how 
concurrency bugs propagate to vulnerable instructions in source code. This 
section first gives two concurrency attack examples our preliminary study 
successfully constructed (\S\ref{sec:examples}), and then proposes 
our model (\S\ref{sec:attack-phase}).

\vspace{-.15in}\subsubsection{Concurrency Attacks Examples In Our Preliminary 
Study} 
\label{sec:examples}\vspace{-.075in}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{figures/libsafe}
\vspace{-.05in}
\caption{{A concurrency attack in the Libsafe security library.}} 
\label{fig:libsafe}
\vspace{-.15in}
\end{figure}

Figure~\ref{fig:libsafe} shows the code of a concurrency attack in 
\libsafe, a popular stack overflow protection library. This library 
provides its own safe memory and string operations functions. For instance, the 
\texttt{libsafe\_strcpy()} function checks whether a stack variable is passed 
in as the function argument \texttt{dest} before it calls the actual 
\texttt{strcpy()}. If a program receives a kill signal, Libsafe's internal 
thread (thread 1) sets a global variable \texttt{dying}, then security checks 
are disabled in \texttt{libsafe\_strcpy()}. Unfortunately, \v{dying} was not 
protected by mutex locks. In our study, we triggered a data race on this 
variable, bypassed the security check, and overflowed thread 2's stack by 
passing malicious code to \texttt{dest}. Ironically, this \libsafe library is 
no longer ``safe" when facing concurrency attacks.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\columnwidth]{figures/apache}
\vspace{-.05in}
\caption{{A concurrency attack in the \apache web server.}} \label{fig:apache}
\vspace{-.15in}
\end{figure}

Figure~\ref{fig:apache} shows the code of a concurrency attack in 
the widely used \apache web server for maintaining users' HTTP pages. \apache 
spawns a number of threads, each serves a HTTP request. Each thread also 
records the request in a global log buffer in heap and flushes this buffer to a 
log file when the buffer is full. However, developers missed a mutex lock to 
protect this buffer, so the buffer can overflow and corrupt adjacent memory, 
including the log file's descriptor. In our study, we corrupted this descriptor 
and made \apache write a request record to mess up another user's HTTP page.



\vspace{-.15in}\subsubsection{Concurrency Attack Model} 
\label{sec:attack-phase}\vspace{-.075in}

A key question on modeling concurrency attack is: how does the corrupted memory 
in a concurrency bug propagate to vulnerable instructions in souce code? Since 
existing reliability tools (\S\ref{sec:others-work}) are already effective on 
detecting concurrency bugs, if our model can address this question, we can 
effectively identify which concurency bugs have the potential to lead to 
attacks, and we can safely ignore those don't.

% P3: pattern.
Although the two aforementioned examples appear to be diverse, we have 
identified three common elements in these concurrency attacks. First, it is 
necessary to have corrupted global memory (\eg, \texttt{dying} in \libsafe, and 
the \texttt{buf\_len} in \apache) caused by concurency bugs. Second, it is 
necessary to have a vulnerable instruction (\eg, \texttt{strcpy()} or 
\texttt{setuid()}) to perform an attack. Third, the corrupted values in global 
memory must cause abnormal behavior on the vulnerable instructions. For 
example, the abnormal behavior in \libsafe is we must leverage the corrupted 
memory to bypass the stack overflow check, an abnormal control-flow of the 
execution. For \apache, we must directly corrupt (\ie, overflow) the buffer 
log, an abnormal data-flow of the execution.

% In sum, three common elements compose a concurrency attack model: corrupted 
% memory, security-sensitive operation, and impact (indirect or direct) from 
the % memory to the operation.
% 
In addition to these two examples, the \nattacks concurrency attacks in recent 
study~\cite{con:hotpar12} and the \noldattacks ones our own preliminary study 
\S\ref{sec:examples}) also have the three common elements. For the first 
element, these attacks have four types of concurrency bugs, including data 
races, atomicity violations, deadlocks, and order violations. For the second 
element, we have collected three types of vulnerable instructions, including 
memory operations (\eg, \texttt{strcpy()}), pointer deferences (\eg, when the 
pointer is NULL), and systems calls (\eg, \texttt{setuid()}). For the third 
element, the key is to detect abnormal control-flow and data-flow of 
executions, and \S\ref{sec:detect} will proposse our systematic detection 
approach.

% PX: emphasis the contribution/potential value of this model.
% In a high level, this model treats a concurrency attack as a source-sink 
model, 
% where a source is a corrupted global memory caused by a concurrency bug, and 
a 
% sink is a security-sensitive operation. Then this model tracks the data flow 
% and control flow of the corrupted memory to the sensitive operations. Unlike 
a 
% traditional model which only consider inputs as the source, our model 
considers
% concurrency bugs as the the inputs. This model spurs several interesting 
% research questions. First, how do we track down the corrupted memory in the 
% middle of an execution? Second, given that concurrency bugs are not only just 
% one, how does our analysis handle multiple concurrency bugs (\eg, multiple 
% corrupted variables)? Third, given that not all security-sensitive operations 
% are indeed relevant to the source, how do we prune the irrelevant operations 
% soundly (\ie, without missing exploits)? In \S\ref{sec:detect}, we plan to 
% leverage this model to develop an effective detection approach, and our 
% preliminary work has shown promising results on addressing these research 
% questions.

% TBD: add a table on the list of concurrency bugs and the list of dangerous 
% operations.



% P5: how to handle unknow patterns? Just say patterns in our work may spur new 
% patterns. We will continue to find new patterns as well.
% P5: TBD.

% \subsubsection{Concurrency Attacks with Three Common Patterns}
% \label{sec:model-pattern}

% Goal 1: modeling.

\vspace{-.15in}\subsection{Objective 2: Detecting Concurrency Attacks in 
Testing Phase}\label{sec:detect}\vspace{-.075in}

To detect the abnormal control-flow and data-flow between corrupted global 
memory to vulnerable instructions, we propose a systematic detection approach. 
Our tool takes program source code as input, and its output is whether this 
program has potential concurrency attacks. This approach is mainly for program 
developers to detect potential attacks and fix them during the software testing 
phase.

This detection approach is also useful for analyzing concurrency bugs and their 
potential attacks in old releases of software programs. The reason is because 
even if concurrency bugs were already fixed in the latest software release, if 
concurrency attacks have occurred and hackers have broken in, fixing the bugs 
won't help.

% For example, we studied a 
% few concurrency bugs in old Linux and BSD releases a few years ago, and their 
% attacks are still helpful because if attackers have broken in and gain root 
% privilege, simply fixing the 
% bugs or upgrading kernels can not remove the malicious root user.

\vspace{-.15in}\subsubsection{Workflow of \xxx's Detection Approach}
\label{sec:detect-arch}\vspace{-.075in}

We foresee two major goals for an effective concurrency attack detection 
apporach. First, a concurrency attack detection report should contain 
preconditions on program inputs so that developers can easily reproduce the 
attack. This goal is especially useful for developers to triggering attacks on 
rare inputs. For example, in a MySQL concurrency attack~\cite{XXX}, only feeding
nested \texttt{select} statements to the MySQL server can trigger this attack.

Second, this approach should be precise in terms of having as few as false 
positives (reports but actually not a feasible attack) and false negatives 
(missing a real attack). To this end, this approach should capture only the 
data-flow and control-flow relevant for the propagation from corrupted memory 
to vulnerable instructions, and it should discard the irrelevant ones. 

Our proposed solution to achieve the first goal is \emph{symbolic 
execution}~\ref{sec:others-work}, a program analysis technique that 
systematicallys explore a program's execution paths to find bugs. Unlike normal 
execution which runs on a concrete inputs, this technique marks inputs (\eg, 
command line arguments and bytes received from network) as symbolic and tracks 
down the input preconditions on control statements (\eg, \texttt{if} and 
\texttt{while}) during the execution. If a control statement depends on inputs, 
symbolic execution forks a new execution, let the two exeuctions go down 
different paths, and tracks input preconditions on each execution. If one 
execution hit a bug, the input preconditions reflect which inputs can trigger 
this bug. This technique has shown to find subtle bugs in real-world programs.

Our proposed solution to achieve the second goal is \emph{path slicing}.Given a 
trace of executed instructions and one essential instruction in this trace, 
path slicing starts from this essential instruction, goes backward the trace, 
and compute a subset of instructions that are necessary to determine the 
reachability and values of operands of this instruction. This path slicing 
technique has shown to compute compact input preconditions to block malicious 
inputs~\cite{castro:bouncer} and compute relevant instructions for programming 
rule violations~\cite{woodpecker:asplos13}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\columnwidth]{figures/detection}
\vspace{-.05in}
\caption{{Workflow of the concurrency attack detection scheme.}} 
\label{fig:detection}
\vspace{-.05in}
\end{figure}

By leveraging the symbolic execution and path slicing, we propose a systematic 
concurrency attack detection approach. The workflow of the approach is shown in 
Figure~\ref{fig:detection}. This approach takes program source code as input 
and uses the LLVM compiler framework to compile it to LLVM IR instructions. The 
symbolic execution engine marks a program input and bytes received from network 
as symbolic and explore program paths. For each execution, we collect all the 
the executed instructions as a trace, and run a race detector on the trace: if 
a concurrency bug is detected, we feed this trace to path slicer to see 
whether: (1) the trace may have contained a vulnerable instruction, or (2) 
this trace have any control statements that can lead to vulnerable instruction 
in the not executed branches. If the trace does not satisfy any of the two 
conditions, we then safely discard this trace.

The path slicer is the key weapon to track the propogation from a concurrency 
bug to potential vulnerable instruction. The slicer takes an execution trace as 
input, and it first sees whether this trace already contains a vulnerable 
instruction, if so, it reports this trace as a potential concurrency attack with 
input preconditions for developers to reproduce this execution. If this trace 
does not contain any type of vulnerable instruction (\S\ref{sec:model}), the 
path slicer starts from the last execution of the trace, goes backward, and 
collect control statements that may lead to a vulnerable instruction. After 
processing the whole trace, the path slicer lets the symbolic execution engine 
explore these control statements with high priority and see whether the 
following executions may exercise potential vulnerable instructions.

% P1: why need a detection scheme. First, capture as many as exploits in 
% testing phase. And call for re-install if there is any potential exploit. 
% Even for 
% old concurrency bugs, it is still necessary because exploits may have already 
% occured and attackers may have already broken in.

% P2: two research questions. Given a concurrency bug, will it lead to an 
% exploit?

% P3: if this bug may lead to an exploit, what inputs may lead to such exploits?

% P4: how to incorporate the patterns in previous section?

% P5: go over the workflow, which is a straight line of boxes. May add some 
% back edges to make it an iterative approach?
 
% \subsubsection{Implementing \xxx's Detection Scheme}\label{sec:detect-impl}
% TBD

% \vspace{-.15in}\subsubsection{Preliminary Results}
% \label{sec:detect-result}\vspace{-.075in}

% P1: we have implemented part of the dangerous operation. pointer NULL 
% derefence. Report the results. FP:FN. 
\para{Preliminary Results.} My collaborators and I have built two basic 
building blocks of this detection approach. First, we have presented a 
preliminary path slicer called Woodpecker~\cite{woodpecker:asplos13} in 
in ASPLOS 2013 for detecting single-threaded security violations on system 
calls (\eg, \texttt{setuid()}). Woodpecker detects 113 programming rule 
violations in 136 popular systems programs, including 10 serious data loss 
errors with seven most serious ones already confirmed by the corresponding 
developers. Second, my collaborators and I have also built a data race detector 
in our and Peregrine~\cite{peregrine:sosp11} paper in SOSP 2011. This race 
detector has detected several new data races in heavily-studied 
programs~\cite{wu:pldi12} in PLDI 2012. We believe that these preliminary 
results show the feasibility of our proposed concurrency attack detection 
approach.

% P2: mention our initial work in OSDI '10 and SOSP '11 on precise data race 
% detection.


% P2: we foresee a few open challenges on the continuation of developing this 
% tool. First, how to make path slicing handle % non-function calls. Second, 
% how 
% to prioritize different operations ()? % Third, how to select malicious 
% inputs and thread schedules that are more likely to triger concurrency bugs?
\para{Open Research Challenges.} We foresee a few open challenges on the 
continuation of developing this tool. First, how to make path slicing handle 
ad-hoc vulnerable instructions (\eg, NULL pointer dereference). Second, how to 
prioritize different vulnerable instructions (\eg, some \v{strcpy} functions do 
not involve with inputs and thus are secure)? Third, how to direct our symbolic 
execution engine to select malicious inputs and thread schedules that are more 
likely to trigger concurrency bugs? I believe these challenges will continue to 
lead to significant research work.

\vspace{-.15in}\subsection{Objective 3: Defensing Concurrency Attacks in 
Deployment Phase} 
\label{sec:defense}\vspace{-.075in}

% P1: motivation, why runtime detection is important. We want to mostly avoid 
% exploits by preventing attackers from manipulating the schedules.
Although \S\ref{sec:detect} has proposed an detection scheme for developers to 
find concurrency attacks in the testing phase, this scheme can not catch 100\% 
attacks because it is designed to find attacks on the concurrency bugs it meets 
at runtime. Thus, to practically prevent concurrency attacks taking over 
multi-threaded programs in the deployment phase, an efficient, transparent 
runtime infrastructure is needed to defense concurrency attacks.

% P2: reason 2: when races occur even if Parrot is enforced, we want to have 
% fault-tolerance.
To build a defense infrastructure, I propose to leverage state machine 
replication (or \smr), a powerful fault-tolerance concept in today's 
distributed system and clouds. \smr models a program as a deterministic
state machine, where the states are important program data and the transitions 
are deterministic executions of program code under input requests. SMR runs 
replicas of the program and invokes a distributed consensus protocol 
(typically \paxos) to ensure the same sequence of input requests for replicas, 
as long as a quorum (typically a majority) of the replicas agrees on the input 
request sequence. Under the deterministic execution assumption, this quorum of 
replicas must reach the same exact state despite various exceptions such as 
program failures or network partitions. SMR is proven safe in theory and 
provides high availability in practice.

The fault-tolerant benefit of \smr makes it particularly attractive
on implementing a principled replication system for tolerating concurrency 
attacks. Unfortunately, doing so is quite challenging, and I foresee four 
challenges.

% P3: reason 3: we want survive. checkpoint and re-execute, and diversify the 
% schedules before re-execute. Sell it like a self-healing runtime system.
First, today's multithreaded programs are almost universally
multithreaded, thus even concurrency attacks do not manifest, the programs 
running across replicas can still easily run into different thread schedules 
and divergent execution states. Second, to leverage existing SMR systems such 
as ZooKeeper, developers often have to shoehorn their programs into the 
narrowly defined state machine interfaces provided by these SMR systems. Third, 
such a runtime infrastructure should run almost as fast as the native 
executions in the deployment phase. Fourth, if replicas run into buggy 
schedules that trigger concurrency attacks, our infrastructure should be able 
to recover from the attacks.

\vspace{-.15in}\subsubsection{Architecture of \xxx's Runtime Defense 
Infrastructure} 
\label{sec:defense-arch}\vspace{-.075in}

\begin{figure}[ht]
\centering
\includegraphics[width=0.3\columnwidth]{figures/defense}
\vspace{-.05in}
\caption{{A runtime infrastructure to defense concurrency attacks.}} 
\label{fig:defense}
\vspace{-.05in}
\end{figure}

To address these challenges, I propose a \smr-based replication 
system. With this infrastructure, a developer focuses on implementing her 
program's intended functionality, not how to defense concurrency attacks. When 
she is ready to replicate her program for strengthened security, she simply
runs this infrastructure with her program on multiple replicas. Within
each replica, this infrastructure interposes on the socket and the thread
synchronization interfaces to keep replicas in sync. Specifically, to address 
the first challenge, it considers each incoming socket call (e.g., accept() a 
client's connection or recv() a client's data) an input request, and runs a 
\paxos consensus protocol to ensure that a quorum of the replicas sees the same 
exact sequence of the incoming socket calls.

To address the second challenge, this infrastructure schedules synchronizations 
using deterministic multithreading (DMT). This technique
typically maintains a global, monotonically increasing logical clock that 
advances deterministically on each thread's synchronization. By serializing 
thread synchronizations, DMT practically makes an entire multithreaded 
execution deterministic. The overhead
of DMT is typically moderate because most code is not synchronization and can 
still run in parallel.

\begin{figure}[ht]
\centering
\includegraphics[width=0.3\columnwidth]{figures/healing}
\vspace{-.05in}
\caption{{The self-healing idea for recovering from concurrency attacks.}} 
\label{fig:healing}
\vspace{-.05in}
\end{figure}

% Mention the self healing idea.
To address the fourth challenge, we propose a self-healing idea 
(Figure~\ref{fig:healing}), which leverage existing transparent program 
checkpoint and restore techniques. On program starts, one backup replica first 
checkpoints the program, and then the program runs as is. Once minor replicas 
hit concurrency attacks, the other replicas can still agree on new inputs and 
process requests. If all replicas fail due to hitting the same vulnerable 
schedule, we simply extracts a previous checkpoint, shuffle the schedules, and 
then let the program continues to execute. To this end, this idea checkpoint 
and recovery must work with general programs with its file system. To this end, 
it leverages CRIU to checkpoint and restore process states, and LXC for file 
system states.

As a typical security setting, we need to define which components of 
this Infrastructure must be trusted. In this project, we require the 
infrastructure and the checkpoints are trusted (\ie, even if the program 
compromises, its program checkpoints and the infrastructure are not effected). 
We consider this requirement as reasonable, because once this infrastructure is 
built, we can leverage existing verification techniques to focus on verifying 
this infrastructure, and on top of it, we no longer need to verify those 
programs.




% P4: challenges on doing so. Including the initial work.

\vspace{-.15in}\subsubsection{Preliminary Results} 
\label{sec:defense-result}\vspace{-.075in}

% P1: we have built a replication system. Perf and checkpoint results.
My collaborators and I have built a prototype system~\cite{crane:sosp15} to 
address the first two challenges. \crane has shown to be able to transparently 
and efficiently support four general multithreaded programs without modifying 
them. We have also shown that this infrastructure is robust on primary replica 
or backup failures. For the third challenge, we plan to study more 
programs and see whether we can leverage performance hints to optimize 
performance. For the fourth challenge, our prototype system \crane has 
implemented a basic checkpoint/restore feature.

\vspace{-.15in}\subsection{Research Plan} \label{sec:plan}\vspace{-.075in}

This \xxx project will require two PhD students S1 and S2 for a period of 
three years. In the first year, S1 will develop and refine the concurrency 
attack model (Objective 1), and S2 will leverage the model to design the 
detailed workflow of the detection approach (part of Objective 2) by working 
closely with S1. In the second year, S1 will do an emperical study on how well 
the model represents real-world concurrency attacks, and S2 will implement 
the detection approach as a software tool (part of Objective 2). In the third 
year, S1 will build the runtime defense infrastructure (Objective 3), and S2 
will apply our model, detection tool, and defense infrastructure to benefit 
other research areas (\eg, byzantine fault tolerance). Overall, both the two 
students will involve theoretical methods, implement real software systems, and 
perform real-world study. The PI will supervise the students by providing 
advice 
concerning both theoretical and systems implementation levels.


