
\section{Research Background} \label{sec:related}

This section introduces the background of concurrency bugs and 
their consequence on concurrency attacks (\S\ref{sec:background}), 
presents others' related work (\S\ref{sec:others-work}), and then introduces 
the PI's related work (\S\ref{sec:my-work}).

\subsection{Concurrency Bugs and Concurrency Attacks} 
\label{sec:background}

% P1: multithreading, hard to get right, plagued with concurrency bugs. 
Real-world multithreaded programs are plagued with various types of concurrency 
bugs~\cite{lu:concurrency-bugs}, including data races, atomicity violations, 
deadlocks, and order violations. These bugs can easily lead to severe program 
behaviors such as crashes, hangs, and wrong outputs.



% P2: Can lead to various exploits. Mention our initial study, types 
% of software, 
% and types of concurrency exploits. Just like bugs in single threaded program 
% leader to exploits, concurrency bugs can lead to concurrency attacks.
% Mention HotPart, found XX exploits. We: found YY exploits. patterns.
% Two examples.
Worse, a recent study~\cite{con:hotpar12} on 46 real-world concurrency bugs 
from CVE~\cite{cve-races} and open source software's bug databases has shown 
that attackers can leverage concurrency bugs to construct \emph{concurrency 
attacks}, including corruption of critical memory, malicious 
code injection~\cite{libsafe:bug}, and privilege escalation. These attacks 
affect a wide range of multithreaded programs, ranging from applications such as 
KDE, Internet Explorer, Firefox, and Google Chrome, to OS kernels such as 
Windows, MacOS X, Linux, iPhone OS.

Unfortunately, most existing defense techniques are weakened or completely 
bypassed by concurrency attacks because these techniques are mainly designed 
for single-threaded programs. For example, although taint-tracking 
tools~\cite{taintdroid:osdi10, lift:micro06, myers:information, 
valgrind:pldi} have proven effective by associating sensitive input data
with security tags during a program's execution, these tools are weakened in 
the concurrency context because a race on data can corrupt the tags and bypass 
trackings. \S\ref{sec:others-work} will discuss why concurrency attacks can 
weaken various existing defense techniques in more details.

% P3: A key reason: a program can run into too many thread interleavings at 
% runtime.
% Hard to make sure all thread intleravings are correct. Mention our previous 
% work Parrot, exponentially many.
A key reason~\cite{smt:cacm, parrot:sosp13} why multithreaded programs are so 
difficult to get right is that these programs may exercise too many 
possible thread interleavings (or \emph{schedules}) at runtime, depending on 
the permutation orders of inter-thread communications (\eg, mutex 
locks). It is extremely challenging to understand, test, analyze, or verify 
this huge amount of schedules and make sure they are free of concurrency bugs 
and exploits.
% Therefore, to tackle concurrency attacks, our propose models, 
% detection tools, and defense infrastructures take thread schedules into account 
% significantly.

\subsubsection{Our Preliminary Study on Concurrency Attacks} 
\label{sec:out-study}

To guide the development of this \xxx project, we have studied another 23 
real-world concurrency bugs and their consequence on concurrency attacks. We 
have written scripts and constructed inputs to reproduce all these 23 
concurrency bugs: 14 bugs caused Denial of Service (DoS) atttacks in application 
programs (Apache, MySQL, Tomcat, and PgSQL) by causing segmentation faults, 
three bugs caused heap overflows in applications programs (Apache and 
htmlCleaner), five bugs caused privilege escalations in the FreeBSD or Linux 
kernels, and one bug bypassed security checks in a security library Libsafe and 
led to stack overflows. \S\ref{sec:model} will give two concrete 
examples.

We found two interesting points in our study. First, unlike 
state-of-the-art understanding that triggering a concurrency bug require lots of 
repeated executions, some concurrency bugs can be triggered and exploited with 
high probability. For instance, in a MySQL DoS attack, we chose nested 
\texttt{select} statements to successfully construct a concurrency bug with 
escalated privileges of MySQL users. Second, even many of the concurrency bugs 
we studied were old and many of them were fixed by software upgrading, it 
doesn't help to avoid concurrency attacks because hackers may have already 
broken in. Therefore, studying whether existing known concurrency bugs may lead 
to concurrency attacks are crucial.




% This proposed \xxx project takes a thorough approach to cope with concurrency 
% attacks. First, \xxx aims to develop a rigorous model to describe such attacks 
% (\S\ref{sec:model}). Unlike traditional models to deal with sequential attacks, 
% our model must incorporate vulnerable thread interleavings and their security 
% consequences. Second, leveraging this model, it aims to build an effective 
% detection approach for developers to find as many as concurrency attacks in the 
% software testing phase (\S\ref{sec:detect}). Third, \xxx aims to build an 
% efficient, transparent, and robust runtime system to defense concurrency attacks 
% in the software deployment phase (\S\ref{sec:defense}).

% P4: Then, challenges come: a concurrency 
% attack model should incorporate thread interleavings. A detection methond 
% should also consider the consequence of thread interleavings. A runtim 
% technique must think of ways to replicate and reduce the amount thread 
% interleavings.
% P4: TBD.


\subsection{Related Work by Others} \label{sec:others-work}

\para{Reliability tools.} There are various prior work on concurrency error 
detection~\cite{yu:racetrack:sosp,savage:eraser,racerx:sosp03,lu:muvi:sosp,
avio:asplos06,conmem:asplos10}, diagnosis~\cite{racefuzzer:pldi08,
ctrigger:asplos09,atomfuzzer:fse08}, 
and correction~\cite{dimmunix:osdi08,gadara:osdi08,wu:loom:osdi10,cfix:osdi12}. 
These work focus on the concurrency errors themselves, while \xxx's 
proposed concurrency attack detection approach mainly focuses on the security 
consequence of concurrency bugs, so these prior work are complementary to our 
objectives in this proposed project.

\para{TOCTTOU attacks.} TOCTTOU (Time Of Check To Time Of Use) 
attacks~\cite{bishop:tocttou,toctou:fast08,toctou:fast05,toctou:usec03} target 
mainly the file system interface, and leverage the non-atomicity bug on 
time-of-check to time-of-use of a file to gain illegal file access. Concurrency 
attacks are much more challenging than TOCTTOU attacks for two main reasons. 
First, TOCTTOU mainly causes illegal file access, while concurrency attacks can 
cause a much broader range of security vulnerabilities, ranging from gaining 
root privileges, injecting malicious code, to bypassing authentication checks. 
Second, concurrency attacks are mainly caused by concurrency bugs 
on global memory accesses, which is a much more difficult to track than the 
file access API of TOCTTOU attacks.

\para{Security defense techniques.} Defense techniques for 
single-threaded programs have been well studied, including meta-data 
tracking~\cite{taintdroid:osdi10, lift:micro06, myers:information, 
valgrind:pldi}, anomaly 
detection~\cite{taskrecycling:ppopp90,schonberg:pldi89}, address space 
randomization~\cite{ aslr-fail:ccs04}, and static 
analysis~\cite{seth:pldi,engler:vmcai,wagner:syscall:ids,coverity:cacm, 
klee:osdi08}. However, with the presence of 
multithreading, these tools may be largely weakened. For instance, concurrency 
bugs in global memory may corrupt meta data tags in metadata tracking 
techniques. Anomaly detection lacks a model for buggy thread interleavings to 
reasoning about concurrency bugs and their consequence on attacks, which the 
attack model in this proposed project may help. Static analysis has shown to 
find numerous bugs in real-world programs, however, when facing a program's 
huge amount of thread interleavings, static analysis usually reports too many 
false positives and bury the real ones.

\noindent {\bf Symbolic Execution} Symbolic execution is an advanced program 
analysis technique that can systematicaly explore a program's execution paths 
to find bugs.  Researchers have built
scalable and effective symbolic execution systems to detect
errors~\cite{dart:pldi,cute:fse,godefroid:grammar-fuzzing,
godefroid:whitebox-fuzzing,
klee:osdi08,yang:malicious-disk:oakland06,cadar:exe:ccs06,s2e:hotdep09,
taas:socc10}, block malicious inputs~\cite{castro:bouncer}, and preserve 
privacy in error reports~\cite{castro:bug-report-privacy}. Our 
\textbf{Objective 2} will leverage symbolic execution to construct an automated 
concurrency attack detection approach.

\para{Program slicing.}  Program slicing~\cite{Tip:slicing} is a general
technique to prune irrelevant statements from a program or trace.
Recently, systems researchers have leveraged or invented slicing
techniques to block malicious input~\cite{castro:bouncer}, synthesize
executions for better error diagnosis~\cite{esd:eurosys10}, infer source
code paths from log messages for postmortem analysis~\cite{sherlog:asplos10}, 
and identify critical inter-thread reads that may lead to concurrency 
errors~\cite{conseq:asplos11}. Our \textbf{Objective 2} will leverage symbolic 
execution to construct an automated concurrency attack detection approach.

\para{State machine replication (SMR).}  SMR is a widely-adopted 
fault-tolerance technique in clouds and distributed 
systems~\cite{lamportclock,smr:tutorial}. SMR runs the same program on a set of 
physical machines (replicas), and it uses the 
\paxos~\cite{paxos,paxos:simple,paxos:complex} distributed consensus protocol 
to ensure consistent inputs for replicas as long as a majority of replcas is 
working correctly (\ie, even if minor replicas fail, SMR still guarantees 
availability of a program). Our \textbf{Objective 3} of this project will 
leverage SMR to build a runtime defense infrastructure.

% \para{\dmt and \smt systems.}  In order to make multi-threading easier to 
% understand, test, analyze, and replicate, researchers have built two types of 
% reliable multi-threading systems: (1) stable multi-threading systems (or 
% \smt)~\cite{grace:oopsla09, dthreads:sosp11, determinator:osdi10} 
% that aim to reduce the number of possible thread interleavings for program all 
% inputs, and(2) deterministic multi-threading systems (or 
% \dmt)~\cite{dpj:oopsla09,dmp:asplos09,kendo:asplos09,coredet:asplos10,
% dos:osdi10,ddos:asplos13, ics:oopsla13} that aim to reduce the number of 
% possible thread interleavings on each program input. Typically, these systems 
% use deterministic logical clocks 
% instead of nondeterministic physical clocks to make sure inter-thread 
% communications (\eg, \mutexlock and accesses to global variables) can only 
% happen at some specific logical clocks. Therefore, given the same or similar 
% inputs, these systems can enforce the same thread interleavings and eventually 
% the same executions. These systems 
% have shown to greatly improve software reliability, including coverage of 
% testing inputs~\cite{ics:oopsla13} and speed of recording 
% executions\cite{dos:osdi10} for debugging.


% \para{Symbolic execution.} The combination of symbolic and
% concrete executions has been a hot research topic. Researchers
% have built scalable and effective symbolic execution
% systems to detect errors [16–18, 20, 28–30, 49,
% 54], block malicious inputs [21], and preserve privacy in
% error reports [19]. Compared to these systems, TERN applies
% symbolic execution to a new domain: tracking input
% constraints to reuse schedules.
% 
% \para{Program analysis.} TBD. Program slicing [49] is a general 
% technique to prune irrelevant statements from a program or trace. Recently,
% systems researchers have leveraged or invented slicing techniques
% to block malicious input [18], synthesize executions for better error
% diagnosis [57], infer source code paths from log messages for postmortem
% analysis [56], and identify critical inter-thread reads that
% may lead to concurrency errors [59]. Our determinism-preserving
% slicing technique produces a correct trace slice for multithreaded
% programs and supports multiple ordered targets.


\subsection{Related Work by the PI} \label{sec:my-work}
% 
% First emphasis debugging experience on concurrency. Program analysis.
% Then mention security exploits found in Woodpecker.
% Then mention runtime systems.

The PI is an expert on developing program analysis algorithms and 
tools~\cite{wu:pldi12, woodpecker:asplos13, repframe:apsys15}, reliable and 
secure multithreading runtime systems~\cite{smt:cacm, cui:tern:osdi10, 
peregrine:sosp11, parrot:sosp13}, and fault-tolerant distributed 
systems~\cite{crane:sosp15}. The PI's work have been published in 
premier conferences on systems software (OSDI 2010, SOSP 2011, SOSP 2013, SOSP 
2015) and programming languages (PLDI 2012, ASPLOS 2013). In connection to 
this project, he has built a precise program slicing tool (a key building 
block for \textbf{Objective 2}), three reliable multithreading runtime 
systems (a key technique for \textbf{Objective 3}), and one fault-tolerant 
replication system (a key technique for \textbf{Objective 3}).

% In the last four years, the PI has been collaborating 
% with Columbia and CMU researchers to build three \smt systems, 
% \tern~\cite{cui:tern:osdi10}, \peregrine~\cite{peregrine:sosp11}, and 
% \parrot~\cite{parrot:sosp13}, with each addressing distinct research 
% challenges. Notably, \parrot, our latest system, is the first \smt runtime 
% system that is fast (12.7\% mean overhead for all evaluated programs) on a wide 
% range of 100+ popular multi-threaded programs. We have 
% put all \parrot's source code and raw evaluation results on 
% \url{http://github.com/columbia/smt-mc} for future research and industrial 
% deployments. Due to \parrot's high practicality, we plan to leverage it in this 
% proposed \xxx system.

% To show \smt's potential, we have applied these systems to greatly improving 
% software reliability and security, including improving precision and simplicity 
% of program analysis and verification~\cite{wu:pldi12}, making debugging 
% concurrency errors much easier~\cite{cui:tern:osdi10}, and improving coverage 
% of model checking~\cite{parrot:sosp13}. Our work have also been leveraged by 
% the community: some techniques in our \tern system~\cite{cui:tern:osdi10} has 
% been used by University of Washington Seatle researchers on computing a small 
% set of thread interleavings covering all inputs~\cite{ics:oopsla13}, and our 
% \parrot runtime system has been integrated with a CMU software model 
% checker~\cite{dbug:spin11}.
% 
% Our experience on building \smt runtime sytems can address the two 
% aforementioned major research challanges of the \smt and SMR integration. In 
% addition, our techniques on program analysis, verification, and model checking 
% can be deployed in \xxx replicas and enhance their reliability and security.


