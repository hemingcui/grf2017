\vspace{-.15in}\section{Research Background} 
\label{sec:background}\vspace{-.075in}

This section first introduces the background of distributed consensus 
(\S\ref{sec:consensus}) and datacenter computing infrastrutures 
(\S\ref{sec:datacenter}). It then presents the motivation of objectives
(\S\ref{sec:motivation}), others' related work (\S\ref{sec:others-work}), and 
the PI's related work (\S\ref{sec:my-work}).

\vspace{-.15in}\subsection{Paxos Consensus} 
\label{sec:consensus}\vspace{-.075in}

Consensus protocols (typically, 
\paxos~\cite{paxos:practical,paxos,paxos:simple,paxos:complex}) play a core
role in datacenters, including 
ordering services~\cite{ellis:thesis,manos:hotdep10,scatter:sosp11},
leader election~\cite{zookeeper, chubby:osdi}, and
fault-tolerance~\cite{eve:osdi12,rex:eurosys14,crane:sosp15}. A \paxos protocol
replicates the same application on a group of computers (or replicas) and 
enforces a strongly consistent order of inputs for this application, as long as 
a majority of replicas still behave correctly. This makes \paxos tolerate 
various faults, including minor replica and network failures.

Due to this strong fault-tolerance, \paxos is widely served in many systems.
For instance, Scatter~\cite{scatter:sosp11} runs 8$\sim$12 replicas in each
\paxos group to order client requests, and it lets replicas respond requests
in parallel. A bigger group size will improve Scatter throughput. 
Moreover, recent state machine replication (SMR) 
systems~\cite{eve:osdi12,rex:eurosys14,crane:sosp15} use \paxos to greatly 
improve the availability of general server applications (\eg, \mysql).

Unfortunately, despite much effort, the group size of traditional \paxos 
protocols can hardly go up to a dozen because their consensus messages 
go through TCP/IP layers (an RTT often takes hundreds of \us), causing the 
consensus latency to increase almost linearly to the group size.

To address this \paxos performance problem, RDMA networking (\eg, 
Infiniband~\cite{infiniband}) becomes a promising direction because its recent 
commonplace in datacenters and and its decreasing prices. An RDMA RTT takes 
only about 3 \us~\cite{pilaf:usenix14}. This ultra low latency not only comes 
from its kernel bypassing feature, but also its dedicated network stack 
implemented in hardware. Therefore, RDMA is considered the fastest kernel 
bypassing technique~\cite{herd:sigcomm14,pilaf:usenix14,dare:hpdc15}; it is 
several times faster than software-only kernel bypassing techniques (\eg, 
DPDK~\cite{dpdk} and Arrakis~\cite{arrakis:osdi14}).

\vspace{-.15in}\subsection{Datacenter Computing Infrastrutures}
\label{sec:datacenter}\vspace{-.075in}

Schedulers: TBD.

VM: TBD.


\vspace{-.15in}\subsubsection{Motivation of Proposed Objectives} 
\label{sec:motivation}\vspace{-.075in}

TBD.

\vspace{-.15in}\subsection{Related Work by Others} 
\label{sec:others-work}\vspace{-.075in}

\para{Various Consensus Protocols.}

\para{Fault-tolerance in datacenter schedulers.} 

\para{Primary-backup in VM.} 

\para{HPC.} HPC already has a replication study. Most of them are in the MP 
mannor so not our focus, although the techniques developed in this proposal can 
be applied to HPC.

\vspace{-.15in}\subsection{Related Work by the PI} 
\label{sec:my-work}\vspace{-.075in}
% 
% First emphasis debugging experience on concurrency. Program analysis.
% Then mention security exploits found in Woodpecker.
% Then mention runtime systems.

The PI is an expert on program analysis algorithms and 
tools~\cite{wu:pldi12, woodpecker:asplos13, repframe:apsys15}, reliable and 
secure multithreading runtime systems~\cite{smt:cacm, cui:tern:osdi10, 
peregrine:sosp11, parrot:sosp13}, and fault-tolerant distributed 
systems~\cite{crane:sosp15}. The PI's works are published in 
premier conferences on systems software (OSDI 2010, SOSP 2011, SOSP 2013, and 
SOSP 2015) and programming languages (PLDI 2012 and ASPLOS 2013). In connection 
to this project, the PI has developed a precise program slicing algorithm (a 
key technique for \textbf{Objective 2}) and two reliable runtime systems (key 
techniques for \textbf{Objective 3}).




