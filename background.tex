
\vspace{-.15in}\section{Research Background} \label{sec:related}\vspace{-.075in}

This section introduces the background of concurrency bugs and 
their consequence on concurrency attacks (\S\ref{sec:background}), 
presents others' related work (\S\ref{sec:others-work}), and then introduces 
the PI's related work (\S\ref{sec:my-work}).

\vspace{-.15in}\subsection{Concurrency Bugs and Concurrency Attacks} 
\label{sec:background}\vspace{-.075in}

% P1: multithreading, hard to get right, plagued with concurrency bugs. 
Real-world multithreaded programs are plagued with various types of concurrency 
bugs~\cite{lu:concurrency-bugs}, including data races, atomicity violations, 
deadlocks, and order violations. These bugs can easily lead to severe program 
behaviors such as crashes, hangs, and wrong outputs.



% P2: Can lead to various exploits. Mention our initial study, types 
% of software, 
% and types of concurrency exploits. Just like bugs in single threaded program 
% leader to exploits, concurrency bugs can lead to concurrency attacks.
% Mention HotPart, found XX exploits. We: found YY exploits. patterns.
% Two examples.
Worse, recent research~\cite{con:hotpar12} on 46 real-world concurrency bugs 
from CVE~\cite{cve-races} and open source software's bug databases reveals 
that hackers have leveraged concurrency bugs to construct \emph{concurrency 
attacks}, including corrupting critical memory~\cite{apache-bug-25520}, 
injecting malicious code~\cite{libsafe:bug}, and escalating 
privilege~\cite{uselib-bug-12791}. These 46 attacks affect a wide range of 
multithreaded programs, ranging from applications such as KDE, Internet 
Explorer, Firefox, and Google Chrome, to OS kernels such as Windows, MacOS X, 
Linux, iPhone OS.

Unfortunately, most existing defense techniques are weakened or completely 
bypassed by concurrency attacks because these techniques are mainly designed 
for single-threaded programs. For example, 
taint-tracking~\cite{taintdroid:osdi10, lift:micro06, myers:information, 
valgrind:pldi}, a runtime technique that tracks sensitive input data by 
associating security tags as metadata for each data byte, is weakened when running with 
multithreading programs because a race on data can corrupt the tags. \S\ref{sec:others-work} 
will discuss how concurrency attacks weaken various defense techniques in 
details.

% P3: A key reason: a program can run into too many thread interleavings at 
% runtime.
% Hard to make sure all thread intleravings are correct. Mention our previous 
% work Parrot, exponentially many.
% A key reason~\cite{smt:cacm, parrot:sosp13} why multithreaded programs are so 
% difficult to get right is that these programs may exercise too many 
% possible thread interleavings (or \emph{schedules}) at runtime, depending on 
% the permutation orders of inter-thread communications (\eg, mutex 
% locks). It is extremely challenging to understand, test, analyze, or verify 
% this huge amount of schedules and eliminate concurrency bugs or attacks in 
% these schedules.
% Therefore, to tackle concurrency attacks, our propose models, 
% detection tools, and defense infrastructures take thread schedules into account 
% significantly.



\vspace{-.15in}\subsubsection{Our Preliminary Study on Concurrency Attacks} 
\label{sec:out-study}\vspace{-.075in}

To guide the development of this \xxx project, we have studied another 23 
real-world concurrency bugs and their consequence on concurrency attacks. We 
have written scripts and constructed inputs to reproduce all these 23 
concurrency bugs: 14 bugs caused Denial of Service (DoS) attacks in application 
programs (Apache, MySQL, Tomcat, and PgSQL) by causing segmentation faults, 
three bugs caused heap overflows in applications programs (Apache and 
htmlCleaner), five bugs caused privilege escalations in MySQL or Linux kernels, 
and one bug bypassed security checks in a security library \libsafe and led to 
stack overflows. \S\ref{sec:model} will give two concrete bug examples.

We have two new discoveries in this study. First, many concurrency bugs can be 
triggered and exploited easily with crafted inputs. For instance, in a MySQL 
concurrency attack~\cite{mysql-bug-14747}, we chose nested 
\texttt{select} statements to trigger the bug and corrupted another 
MySQL user's privilege table by only 18 repeated executions. In a Linux kernel 
exploit~\cite{uselib-bug-12791}, we easily got root privilege with 
crafted systems call arguments. Second, although many concurrency bugs we 
studied were already fixed by upgrading program code or executables, the 
programs are still in danger because hackers have already broken in. Therefore, 
studying existing known concurrency bugs is still crucial.

\vspace{-.15in}\subsubsection{Motivation of Objectives in this Proposal} 
\label{sec:out-study}\vspace{-.075in}

To the best of our knowledge, state-of-the-art has no effective approach to 
tackle concurrency attacks due to three major difficulties.  First, 
people may still consider concurrency bugs and attacks are orthogonal 
behaviors because people lack a rigorous model to describe how concurrency bugs 
propagate to vulnerable instructions. Second, detecting a concurrency bug 
requires a systematic approach to carefully choose relevant inputs and thread 
interleavings, and to precisely identify vulnerable instructions in program 
code. Third, defending against concurrency attacks at runtime requires a 
reliable defense infrastructure. This proposal addresses each difficulty with 
an objective.


% This proposed \xxx project takes a thorough approach to cope with concurrency 
% attacks. First, \xxx aims to develop a rigorous model to describe such attacks 
% (\S\ref{sec:model}). Unlike traditional models to deal with sequential attacks, 
% our model must incorporate vulnerable thread interleavings and their security 
% consequences. Second, leveraging this model, it aims to build an effective 
% detection approach for developers to find as many as concurrency attacks in the 
% software testing phase (\S\ref{sec:detect}). Third, \xxx aims to build an 
% efficient, transparent, and robust runtime system to defense concurrency attacks 
% in the software deployment phase (\S\ref{sec:defense}).

% P4: Then, challenges come: a concurrency 
% attack model should incorporate thread interleavings. A detection methond 
% should also consider the consequence of thread interleavings. A runtim 
% technique must think of ways to replicate and reduce the amount thread 
% interleavings.
% P4: TBD.


\vspace{-.15in}\subsection{Related Work by Others} 
\label{sec:others-work}\vspace{-.075in}

\para{Reliability tools.} There are various prior works on concurrency error 
detection~\cite{yu:racetrack:sosp,savage:eraser,racerx:sosp03,lu:muvi:sosp,
avio:asplos06,conmem:asplos10}, diagnosis~\cite{racefuzzer:pldi08,
ctrigger:asplos09,atomfuzzer:fse08}, 
and correction~\cite{dimmunix:osdi08,gadara:osdi08,wu:loom:osdi10,cfix:osdi12}. 
These works mainly focus on the concurrency bugs themselves, and our
proposed objectives focus on the security consequence of concurrency 
bugs. Therefore, these works are complementary to ours.

\para{TOCTTOU attacks.} TOCTTOU (time-of-check-to-time-of-use) 
attacks~\cite{bishop:tocttou,toctou:fast08,toctou:fast05,toctou:usec03} target 
mainly the file system interface, and leverage the non-atomic nature on 
time-of-check (\eg, \texttt{access()}) to time-of-use (\eg, \texttt{open()}) of 
a file to gain illegal file access. The concurrency attacks we target in this 
proposal are much more challenging than TOCTTOU attacks for two main reasons. 
First, TOCTTOU mainly causes illegal file access, while concurrency attacks can 
cause a much broader range of security vulnerabilities, ranging from gaining 
root privileges~\cite{uselib-bug-12791}, injecting malicious 
code~\cite{uselib-bug-12791}, to corrupting 
critical memory~\cite{apache-bug-25520}. Second, concurrency attacks are mainly 
triggered by global memory access, much more difficult to track than the file 
access in TOCTTOU attacks.

\para{Security defense techniques.} Defense techniques for 
single-threaded programs have been well studied, including meta-data 
tracking~\cite{taintdroid:osdi10, lift:micro06, myers:information, 
valgrind:pldi}, anomaly 
detection~\cite{taskrecycling:ppopp90,schonberg:pldi89}, address space 
randomization~\cite{ aslr-fail:ccs04}, and static 
analysis~\cite{seth:pldi,engler:vmcai,wagner:syscall:ids,coverity:cacm, 
klee:osdi08}. However, with the presence of 
multithreading, these tools can be largely weakened. For instance, concurrency 
bugs in global memory may corrupt meta data tags in metadata tracking 
techniques. Anomaly detection lacks a concurrency model to reason about 
concurrency bugs and attacks. Static analysis has shown to find numerous bugs in 
real-world programs, however, when facing a program's huge amount of thread 
interleavings, static analysis usually reports too many false positives and bury 
the real ones.

\noindent {\bf Symbolic execution.} Symbolic execution is an advanced program 
analysis technique that can systematically explore a program's execution paths 
to find bugs.  Researchers have built
scalable and effective symbolic execution systems to detect
errors~\cite{dart:pldi,cute:fse,godefroid:grammar-fuzzing,
godefroid:whitebox-fuzzing,
klee:osdi08,yang:malicious-disk:oakland06,cadar:exe:ccs06,s2e:hotdep09,
taas:socc10}, block malicious inputs~\cite{castro:bouncer}, and preserve 
privacy in error reports~\cite{castro:bug-report-privacy}. 
\textbf{Objective 2} will leverage symbolic execution to automatically find 
inputs that may trigger concurrency bugs and attacks.

\para{Program slicing.}  Program slicing~\cite{Tip:slicing} is a general
technique to prune irrelevant statements from a program or trace.
Recently, systems researchers have leveraged or invented slicing
techniques to block malicious input~\cite{castro:bouncer}, synthesize
executions for better error diagnosis~\cite{esd:eurosys10}, infer source
code paths from log messages for postmortem analysis~\cite{sherlog:asplos10}, 
and identify critical inter-thread reads that may lead to concurrency 
errors~\cite{conseq:asplos11}. \textbf{Objective 2} will leverage program 
slicing to track the propagation from bugs to attacks.

\para{State machine replication (SMR).}  SMR is a powerful fault-tolerant technique 
in distributed systems~\cite{lamportclock,smr:tutorial}. SMR runs the same program on a set of 
physical machines (replicas), and it uses the 
\paxos~\cite{paxos,paxos:simple,paxos:complex} distributed consensus protocol 
to ensure consistent inputs for replicas as long as a majority of replicas is 
working correctly (\ie, even if minor replicas fail, SMR still guarantees 
availability of a program). \textbf{Objective 3} will leverage SMR to build a 
defense infrastructure.

% \para{\dmt and \smt systems.}  In order to make multi-threading easier to 
% understand, test, analyze, and replicate, researchers have built two types of 
% reliable multi-threading systems: (1) stable multi-threading systems (or 
% \smt)~\cite{grace:oopsla09, dthreads:sosp11, determinator:osdi10} 
% that aim to reduce the number of possible thread interleavings for program all 
% inputs, and(2) deterministic multi-threading systems (or 
% \dmt)~\cite{dpj:oopsla09,dmp:asplos09,kendo:asplos09,coredet:asplos10,
% dos:osdi10,ddos:asplos13, ics:oopsla13} that aim to reduce the number of 
% possible thread interleavings on each program input. Typically, these systems 
% use deterministic logical clocks 
% instead of nondeterministic physical clocks to make sure inter-thread 
% communications (\eg, \mutexlock and accesses to global variables) can only 
% happen at some specific logical clocks. Therefore, given the same or similar 
% inputs, these systems can enforce the same thread interleavings and eventually 
% the same executions. These systems 
% have shown to greatly improve software reliability, including coverage of 
% testing inputs~\cite{ics:oopsla13} and speed of recording 
% executions\cite{dos:osdi10} for debugging.


% \para{Symbolic execution.} The combination of symbolic and
% concrete executions has been a hot research topic. Researchers
% have built scalable and effective symbolic execution
% systems to detect errors [16–18, 20, 28–30, 49,
% 54], block malicious inputs [21], and preserve privacy in
% error reports [19]. Compared to these systems, TERN applies
% symbolic execution to a new domain: tracking input
% constraints to reuse schedules.
% 
% \para{Program analysis.} TBD. Program slicing [49] is a general 
% technique to prune irrelevant statements from a program or trace. Recently,
% systems researchers have leveraged or invented slicing techniques
% to block malicious input [18], synthesize executions for better error
% diagnosis [57], infer source code paths from log messages for postmortem
% analysis [56], and identify critical inter-thread reads that
% may lead to concurrency errors [59]. Our determinism-preserving
% slicing technique produces a correct trace slice for multithreaded
% programs and supports multiple ordered targets.


\vspace{-.15in}\subsection{Related Work by the PI} 
\label{sec:my-work}\vspace{-.075in}
% 
% First emphasis debugging experience on concurrency. Program analysis.
% Then mention security exploits found in Woodpecker.
% Then mention runtime systems.

The PI is an expert on developing program analysis algorithms and 
tools~\cite{wu:pldi12, woodpecker:asplos13, repframe:apsys15}, reliable and 
secure multithreading runtime systems~\cite{smt:cacm, cui:tern:osdi10, 
peregrine:sosp11, parrot:sosp13}, and fault-tolerant distributed 
systems~\cite{crane:sosp15}. The PI's work have been published in 
premier conferences on systems software (OSDI 2010, SOSP 2011, SOSP 2013, SOSP 
2015) and programming languages (PLDI 2012, ASPLOS 2013). In connection to 
this project, he has developed a precise program slicing approach (a key 
technique for \textbf{Objective 2}) and one state-machine replication system (a key 
technique for \textbf{Objective 3}).

% In the last four years, the PI has been collaborating 
% with Columbia and CMU researchers to build three \smt systems, 
% \tern~\cite{cui:tern:osdi10}, \peregrine~\cite{peregrine:sosp11}, and 
% \parrot~\cite{parrot:sosp13}, with each addressing distinct research 
% challenges. Notably, \parrot, our latest system, is the first \smt runtime 
% system that is fast (12.7\% mean overhead for all evaluated programs) on a wide 
% range of 100+ popular multi-threaded programs. We have 
% put all \parrot's source code and raw evaluation results on 
% \url{http://github.com/columbia/smt-mc} for future research and industrial 
% deployments. Due to \parrot's high practicality, we plan to leverage it in this 
% proposed \xxx system.

% To show \smt's potential, we have applied these systems to greatly improving 
% software reliability and security, including improving precision and simplicity 
% of program analysis and verification~\cite{wu:pldi12}, making debugging 
% concurrency errors much easier~\cite{cui:tern:osdi10}, and improving coverage 
% of model checking~\cite{parrot:sosp13}. Our work have also been leveraged by 
% the community: some techniques in our \tern system~\cite{cui:tern:osdi10} has 
% been used by University of Washington Seatle researchers on computing a small 
% set of thread interleavings covering all inputs~\cite{ics:oopsla13}, and our 
% \parrot runtime system has been integrated with a CMU software model 
% checker~\cite{dbug:spin11}.
% 
% Our experience on building \smt runtime sytems can address the two 
% aforementioned major research challanges of the \smt and SMR integration. In 
% addition, our techniques on program analysis, verification, and model checking 
% can be deployed in \xxx replicas and enhance their reliability and security.


