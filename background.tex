
\section{Research Background} \label{sec:related}

This section first introduces the background of concurrency bugs and 
their consequences on leading to concurrency attacks (\S\ref{sec:background}), 
and then presents others' related work (\S\ref{sec:others-work}), and the PI's 
related work (\S\ref{sec:my-work}).

\subsection{Concurrency Bugs and Attacks in Multithreaded Programs} 
\label{sec:background}

% P1: multithreading, hard to get right, plagued with concurrency bugs.
Driven by the prevalance of the multi-core hardware, multithreaded programs 
have become one main stream in real-world software. Unfortunately, despite 
dedades of efforts on developing new theretical primitives and building 
reliability tools, these programs are still notoriously difficult to get right. 
Multithreaded programs are plagued with various types of concurrency bugs, 
including data races, atomicity violations, deadlocks, and order violations. 
These bugs can easily lead to severe program behaviors such as crashes, hangs, 
and wrong outputs.



% P2: Can lead to various exploits. Mention our initial study, types 
% of software, 
% and types of concurrency exploits. Just like bugs in single threaded program 
% leader to exploits, concurrency bugs can lead to concurrency attacks.
% Mention HotPart, found XX exploits. We: found YY exploits. patterns.
% Two examples.
Worse, recent study~\cite{con:hotpar12} on a wide range of real-world 
multithreade programs has shown that attackers can leverage these concurrency 
bugs to construct \emph{concurrency attacks}. Attackers can construct specific 
inputs to trigger concurrency bugs with high probability (\eg, with only tens 
of repeated executions), corrupt critical global memory shared by threads in 
a program, leverage the corrupted values in memory to bypass security 
checks in programs' source code, and finally inject malicious code, gain 
privileges, or bypass authentication procedures.

Unfortunately, most traditional defense techniques are weakened or completely 
bypassed by concurrency attacks because these techniques are mainly designed to 
protect single-threaded programs. For example, authough taint-tracking tools 
have proven effective on tracking inputs' flow to sensitive locations by 
adding security tags to data, these tools are weakened in the multithreading 
context because a race on data can corrupt the tags and bypass tracking. 
\S\ref{sec:others-work} discusses why concurrency attacks can weaken various 
traditional defense techniques in more details. In short, compared to the 
traditional single-threaded programs, multithreaded programs are much more 
difficult to get right.


% P3: A key reason: a program can run into too many thread interleavings at 
% runtime.
% Hard to make sure all thread intleravings are correct. Mention our previous 
% work Parrot, exponentially many.
Our study shows that a key reason why multithreaded programs are so difficult 
to get right is that, at run time, these programs may run into 
exponentially many possible thread interleavings (or \emph{schedules}) 
depending on the permutation orders of inter-thread communication operations 
(\eg, mutex locks). It is extremely challenging to understand, test, analyze, 
or verify this huge amount of schedules and make sure they are free of 
concurrency bugs and exploits. Therefore, state-of-the-art neither has a 
rigourous model on describing concurrency attacks, nor lacks effective 
approaches to detect and defense such attacks.

This \xxx project takes a thorough approach to cope with concurrency attacks.
First, \xxx aims to develop a rigourous model to describe such attacks 
(\S\ref{sec:model}). Unlike traditional models to deal with sequential attacks, 
our model must incorporate vulnerable thread interleavings and their security 
consequences. Second, leveraging this model, it aims to build an effective 
detection approach for developers to find as many as concurrency attacks in the 
software testing phase (\S\ref{sec:detect}). Third, \xxx aims to build an 
efficient, transparent, and robust runtime system to defense concurrency attacks 
in the software deployment phase (\S\ref{sec:defense}).

% P4: Then, challenges come: a concurrency 
% attack model should incorporate thread interleavings. A detection methond 
% should also consider the consequence of thread interleavings. A runtim 
% technique must think of ways to replicate and reduce the amount thread 
% interleavings.
% P4: TBD.


\subsection{Related Work by Others} \label{sec:others-work}

\para{Reliability tools.} There are various prior work on concurrency error 
detection~\cite{yu:racetrack:sosp,savage:eraser,racerx:sosp03,lu:muvi:sosp,
avio:asplos06,conmem:asplos10}, diagnosis~\cite{racefuzzer:pldi08,
ctrigger:asplos09,atomfuzzer:fse08}, 
and correction~\cite{dimmunix:osdi08,gadara:osdi08,wu:loom:osdi10,cfix:osdi12}. 
These work mainly focus on the concurrency errors themselves, while \xxx's 
concurrency attack detection approach mainly focuses on the security 
consenquences of conrrency bugs, so our detection approach is complementary to 
these prior work. These prior work can aslo be deployed on backup 
replicas of \xxx's runtime infrastructure and help \xxx detect concurrency 
errors. Moreover, the asynchronous replication nature of \xxx's runtime 
infrastructure can also mitigate the performance overhead of these powerful 
analyses~\cite{repframe:apsys15}.

\para{TOCTTOU attacks.} TOCTTTOU (Time Of Check To Time Of Use) 
attacks have been well studied for 
decades~\cite{bishop:tocttou,toctou:fast08,toctou:fast05,toctou:usec03}. These 
attacks target mainly the file system interface, and leverage the non-atomicity 
on time-of-check to time-of-use of a file to escalate illegal file access. Our 
\xxx project targets general concurency attacks, which is much broader and 
severe than typical TOCTTTOU attacks for two main reasons. First, TOCTTTOU 
mainly causes illegal file access, while general concurency attacks can cause a 
much broader range of security attacks, ranging from gaining root privileges, 
injecting malicious code, to bypassing authentication checks. Second, the root 
cause of TOCTTTOU attacks is mainly caused by incorrect use of file system API, 
while concurrency attacks are mainly caused by concurrency bugs with memory 
accesses, which is much more difficult to track and prevent.

\para{Traditional security defense techniques.} Defense techniques for 
single-threaded programs have been well studied, including metadata 
tracking~\cite{taintdroid:osdi10, lift:micro06, myers:information, 
valgrind:pldi}, anomaly 
detection~\cite{taskrecycling:ppopp90,schonberg:pldi89}, address space 
randomization~\cite{ aslr-fail:ccs04}, and static 
analysis~\cite{seth:pldi,engler:vmcai,wagner:syscall:ids,coverity:cacm, 
klee:osdi08}.
Say these are mainly for single-threaded programs. However, on the presence of 
multithreading, these tools may be largely weakened. Concurrency 
bugs in global memory may corrupt metadata tags in metadata tracking. Anomaly 
detection lack a model for buggy thread interleavings to reasonabling about 
concurrency bugs and their consenquence on attacks, which our attack model can 
help. Static analysis has shown to find numerous bugs in real-world software, 
however, when reasonabling about the exponentially many thread interleavings, 
static analysis usually report too many false positives and burry the real 
ones. To tackle concurrency attacks, existing defense techniques can leverage 
our concurrency attack model (Objective 1) and use our detection tool 
(Objective 2).

\para{State machine replication (SMR).}  SMR has been studied by the literature 
for decades, and it is recognized by both industry and academia as a powerful 
fault-tolerance technique in clouds and distributed 
systems~\cite{lamportclock,smr:tutorial}. As a common practice, SMR uses 
\paxos~\cite{paxos,paxos:simple,paxos:complex} and its popular engineering 
approaches~\cite{paxos:live,paxos:practical} as the consensus protocol to 
ensure that all replicas see the same input request sequence. Since consensus 
protocols are the core of SMR, a variety of study improve different aspects of 
consensus protocols, including performance~\cite{epaxos:sosp13,paxos:fast} and 
understandability~\cite{raft:usenix14}. Although \xxx's current implementation 
takes a popular engineering approach~\cite{paxos:practical} for practicality, 
it can also leverage other consensus protocols and approaches.

\para{\dmt and \smt systems.}  In order to make multi-threading easier to 
understand, test, analyze, and replicate, researchers have built two types of 
reliable multi-threading systems: (1) stable multi-threading systems (or 
\smt)~\cite{grace:oopsla09, dthreads:sosp11, determinator:osdi10} 
that aim toreduce the number of possible thread interleavings for program all 
inputs, and(2) deterministic multi-threading systems (or 
\dmt)~\cite{dpj:oopsla09,dmp:asplos09,kendo:asplos09,coredet:asplos10,
dos:osdi10,ddos:asplos13, ics:oopsla13} that aim to reduce the number of 
possible thread interleavings on each program input. Typically, these systems 
use deterministic logical clocks 
instead of nondeterministic physical clocks to make sure inter-thread 
communications (\eg, \mutexlock and accesses to global variables) can only 
happen at some specific logical clocks. Therefore, given the same or similar 
inputs, these systems can enforce the same thread interleavings and eventually 
the same executions. These systems 
have shown to greatly improve software reliability, including coverage of 
testing inputs~\cite{ics:oopsla13} and speed of recording 
executions\cite{dos:osdi10} for debugging.


% \para{Symbolic execution.} The combination of symbolic and
% concrete executions has been a hot research topic. Researchers
% have built scalable and effective symbolic execution
% systems to detect errors [16–18, 20, 28–30, 49,
% 54], block malicious inputs [21], and preserve privacy in
% error reports [19]. Compared to these systems, TERN applies
% symbolic execution to a new domain: tracking input
% constraints to reuse schedules.
% 
% \para{Program analysis.} TBD. Program slicing [49] is a general 
% technique to prune irrelevant statements from a program or trace. Recently,
% systems researchers have leveraged or invented slicing techniques
% to block malicious input [18], synthesize executions for better error
% diagnosis [57], infer source code paths from log messages for postmortem
% analysis [56], and identify critical inter-thread reads that
% may lead to concurrency errors [59]. Our determinism-preserving
% slicing technique produces a correct trace slice for multithreaded
% programs and supports multiple ordered targets.


\subsection{Related Work by the PI} \label{sec:my-work}
% 
% First emphasis debugging experience on concurrency. Program analysis.
% Then mention security exploits found in Woodpecker.
% Then mention runtime systems.

The PI is an expert on developing program analysis algorithms and 
tools~\cite{wu:pldi12, woodpecker:asplos13, repframe:apsys15}, reliable and 
secure multithreading runtime systems~\cite{smt:cacm, cui:tern:osdi10, 
peregrine:sosp11, parrot:sosp13}, and fault-tolerant distributed 
systems~\cite{crane:sosp15}. These work have been published in premier 
conferences on systems software (OSDI 2010, SOSP 2011, SOSP 2013, SOSP 2015) and 
programming languages (PLDI 2012, ASPLOS 2013). Most of the PI's work are open 
source. The PI's work has also been featured by media such as Phys.org and 
ACM Tech news. In connection to this project, he has built a precise path 
slicing tool (for Object 2), three deterministic multithreading runtime systems 
(for Object 3), and one fault-tolerant replication system (for Object 3). These 
work can be leveraged as basic building blocks of the detection approach and 
the runtime infrastructure in this proposed project.

% In the last four years, the PI has been collaborating 
% with Columbia and CMU researchers to build three \smt systems, 
% \tern~\cite{cui:tern:osdi10}, \peregrine~\cite{peregrine:sosp11}, and 
% \parrot~\cite{parrot:sosp13}, with each addressing distinct research 
% challenges. Notably, \parrot, our latest system, is the first \smt runtime 
% system that is fast (12.7\% mean overhead for all evaluated programs) on a wide 
% range of 100+ popular multi-threaded programs. We have 
% put all \parrot's source code and raw evaluation results on 
% \url{http://github.com/columbia/smt-mc} for future research and industrial 
% deployments. Due to \parrot's high practicality, we plan to leverage it in this 
% proposed \xxx system.

% To show \smt's potential, we have applied these systems to greatly improving 
% software reliability and security, including improving precision and simplicity 
% of program analysis and verification~\cite{wu:pldi12}, making debugging 
% concurrency errors much easier~\cite{cui:tern:osdi10}, and improving coverage 
% of model checking~\cite{parrot:sosp13}. Our work have also been leveraged by 
% the community: some techniques in our \tern system~\cite{cui:tern:osdi10} has 
% been used by University of Washington Seatle researchers on computing a small 
% set of thread interleavings covering all inputs~\cite{ics:oopsla13}, and our 
% \parrot runtime system has been integrated with a CMU software model 
% checker~\cite{dbug:spin11}.
% 
% Our experience on building \smt runtime sytems can address the two 
% aforementioned major research challanges of the \smt and SMR integration. In 
% addition, our techniques on program analysis, verification, and model checking 
% can be deployed in \xxx replicas and enhance their reliability and security.


